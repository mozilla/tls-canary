# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.

import glob
import io
import json
from nose.tools import *
import os
import unittest.mock as mock

from tlscanary import main
import tests


def test_tlscanary_regression_and_log():
    """TLS Canary can make regression runs"""
    work_dir = os.path.join(tests.tmp_dir, "workdir")

    # Run a quick regression scan, simulating error conditions by -p1
    argv = [
        "--workdir", work_dir,
        "regression",
        "-t", tests.test_archive,
        "-b", tests.test_archive,
        "-l", "9",
        "-p1", "security.tls.version.min;4"
    ]
    ret = main.main(argv)
    assert_equal(ret, 0, "regression run finished without error")

    # Check log
    argv = [
        "--workdir", work_dir,
        "log",
        "-a", "json",
        "-i", "1"
    ]
    with mock.patch('sys.stdout', new=io.StringIO()) as mock_stdout:
        ret = main.main(argv)
        stdout = mock_stdout.getvalue()
    assert_equal(ret, 0, "regression log dump finished without error")
    assert_true(len(stdout) > 0, "regression log dump is not empty")
    log = json.loads(stdout)
    assert_true(type(log) is list, "regression JSON log is list")
    assert_equal(len(log), 1, "there is one log in the dump")
    assert_true("meta" in log[0] and "data" in log[0], "log has meta and data")
    assert_true(len(log[0]["data"]) > 5, "log has correct number of lines")

    # Write HTML report
    # TODO: Regression log was generated by the -p1 hack, thus does not contain certificate data.
    report_dir = os.path.join(tests.tmp_dir, "report")
    argv = [
        "--workdir", work_dir,
        "log",
        "-a", "webreport",
        "-i", "1",
        "-o", report_dir
    ]
    ret = main.main(argv)
    assert_equal(ret, 0, "regression HTML report finished without error")
    assert_true(os.path.isdir(report_dir), "HTML report dir was created")
    assert_true(os.path.isfile(os.path.join(report_dir, "index.htm")), "HTML report index was written")
    runs_file = os.path.join(report_dir, "runs", "runs.json")
    assert_true(os.path.isfile(runs_file), "HTML `runs.json` file was written")
    with open(runs_file) as f:
        runs_lines = json.load(f)
    assert_equal(len(runs_lines), 1, "one HTML run was written")
    run_dir = os.path.join(report_dir, "runs", runs_lines[0]["data"][0]["run"])
    assert_true(os.path.isdir(run_dir), "HTML run dir was created")
    zip_glob = glob.glob(os.path.join(run_dir, "*.zip"))
    assert_equal(len(zip_glob), 3, "three profile archives were written to HTML run dir")


def test_tlscanary_srcupdate_and_scan_and_log():
    """TLS Canary can update source DBs"""
    work_dir = os.path.join(tests.tmp_dir, "workdir")

    # Compile a fresh `nosetest` host db
    argv = [
        "--workdir", work_dir,
        "srcupdate",
        "-b", tests.test_archive,
        "-l", "5",
        "-s", "nosetest"
    ]
    ret = main.main(argv)
    assert_equal(ret, 0, "srcupdate run finished without error")

    # Run a scan against `nosetest` host db
    argv = [
        "--workdir", work_dir,
        "scan",
        "-t", tests.test_archive,
        "-s", "nosetest",
    ]
    ret = main.main(argv)
    assert_equal(ret, 0, "scan run finished without error")

    # Check logs
    argv = [
        "--workdir", work_dir,
        "log",
        "-a", "json",
        "-i", "1"
    ]
    with mock.patch('sys.stdout', new=io.StringIO()) as mock_stdout:
        ret = main.main(argv)
        stdout = mock_stdout.getvalue()
    assert_equal(ret, 0, "scan log dump finished without error")
    log = json.loads(stdout)
    assert_true(type(log) is list, "scan JSON log is list")
    assert_equal(len(log), 1, "there is one log in the dump")
    assert_true("meta" in log[0] and "data" in log[0], "log has meta and data")
    assert_equal(len(log[0]["data"]), 5, "log has correct number of lines")
